ifdef::env-site[]
include::partial$_attributes.adoc[]
endif::[]
:imagesdir: ../../images

= Integrate Docker Images

If you need to extend this environment with your own containers or import additional data, please taken the following guidelines into account.

The following sections describe the necessary steps to integrate your own Docker images into the OneCX Local Environment. We will use a simple "*Hello World*" service as an example, consisting of a backend-for-frontend (BFF) and a UI component.

Overview of the steps to integrate your own Docker images::
* Prepare hosts file entries to access your services via the local proxy.
* Create the required database and user in the Postgres container.
* Prepare your Docker images for the services you want to add.
* Prepare a Docker Compose file to define your services.
* Starting your services


== Prerequisites

=== Add entries in hosts file
To access your Hello World service via the local proxy, add the following entries to your system's hosts file:
[source, bash]
----
127.0.0.1   onecx-hello-world-svc
127.0.0.1   onecx-hello-world-bff
----

=== Create Database and User
Before starting your service, create (if not yet done) the required database and user in the Postgres container.

You can do this by connecting to the Postgres container and executing the necessary SQL commands. Here are the steps:

. Connect to the Postgres container
+
[source, bash]
----
docker exec -it postgresdb psql -U postgres
----

. Create the database and user
+
[source, sql]
----
CREATE USER onecx_hello_world WITH ENCRYPTED PASSWORD 'onecx_hello_world';
CREATE DATABASE onecx_hello_world with owner onecx_hello_world;
GRANT ALL PRIVILEGES ON DATABASE onecx_hello_world TO onecx_hello_world;
GRANT ALL PRIVILEGES ON SCHEMA public TO onecx_hello_world;
----
+
. Exit the *psql* shell
+
[source, bash]
----
\q
----

. Exit the container
+
[source, bash]
----
exit
----

. Verify the database and user creation
+
[source, bash]
----
docker exec -it postgresdb psql -U postgres -c "\l"
docker exec -it postgresdb psql -U postgres -c "\du"
----
+
.Database Verification
image::extend/db-creation_hello-world.png[]
+
.User/Role Verification
image::extend/role-creation_hello-world.png[]

=== Prepare Docker Images
* Build and tag your Docker images according to your versioning strategy. You can either use a local registry or build them locally for direct use. +
* Push your images to your Docker registry if necessary.


=== Prepare Docker Compose File

* Create the file (e.g. `hello-world.compose.yaml`), define your services with image references and tags, environment variables and health checks. +
* Ensure that your file uses the same Compose project name as defined in the OneCX environment file to maintain network and volume consistency.
+
.Compose Project Name
[source,yaml]
----
name: onecx-local-env
----

* Add the OneCX Compose file that you want to use as the basis for inheriting existing service definitions and configurations. The easiest way is to use the file in the root directory of your local OneCX environment (compose.yaml). +
Alternatively, you can reference the version-specific Docker Compose file (e.g., `versions/v2/compose.yaml`).
+
.Include OneCX Local Environment Compose file
[source,yaml]
----
include:
  - compose.yaml
----

* Place the file in the root of the OneCX Local Environment directory.

.Here is an example of a Docker Compose file for the Hello World service
[%collapsible]
====
include::./_onecx-hello-world.adoc[]
====


=== Prepare Environment Settings
To keep the example simple, all necessary environment variables are either taken from the base Compose project (OneCX Local Environment) or defined directly in the Compose file (e.g. username, password).

If you need to define additional environment variables (e.g. for image tags or database connection details), you can do so in a separate environment file. +
If so then this file must be specified when starting the OneCX Local Environment using the `--env-file` option with Docker Compose.


=== Start Services

Before starting your services one word how the services are organized:
* The UI service (`onecx-hello-world-ui`) connects to the BFF service (`onecx-hello-world-bff`).
* The BFF service connects to the backend service (`onecx-hello-world-svc`).
* The backend service connects to the Postgres database.

These conectivity are reflected by the 'depends on' settings in the Docker Compose file. Therefore it is sufficient to start only the UI service, which will automatically start the BFF and backend services as well.

.Start Hello World Services
[source, bash]
----
docker compose --env-file ./versions/v2/.env -f hello-world.compose.yaml up -d onecx-hello-world-ui
----

.Start Hello World Services with extra env file
[source, bash]
----
docker compose --env-file ./versions/v2/.env --env-file ./hello-world.env -f hello-world.compose.yaml up -d onecx-hello-world-ui
----

. Verify that the services are running
[source, bash]
----
docker compose ps
----
